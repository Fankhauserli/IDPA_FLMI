<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>IDPA FLMI — Attention</title>
    <meta name="description" content="Erklärung der Attention Mechanismus in LLMs" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="../../assets/css/styles.css" />
  </head>
  <body class="antialiased bg-gray-50 text-gray-800">
    <header class="bg-white shadow">
      <div class="max-w-6xl mx-auto px-4 sm:px-6 py-6">
        <a href="/" class="text-indigo-600 hover:underline">← Zurück zur Übersicht</a>
        <h1 class="text-3xl font-bold mt-2">Attention</h1>
        <p class="text-gray-600 mt-1">Wie ein neuronales Netzwerk Kontext lernt</p>
      </div>
    </header>
    <main class="max-w-4xl mx-auto px-4 py-12">
      <div class="bg-white p-8 rounded-lg shadow space-y-8">

        <div>
          <p class="text-lg leading-relaxed">Im Einbettungsschritt haben wir den Input ins LLM in verschiedenen Token aufgetrennt und für jeden Token ein Vektor erhalten. Dies ist jedoch noch sehr linear, das Wort Bank wird immer als gleicher Vektor interpretiert. Die unterschiedliche Bedeutung des Wortes “Bank” können nicht widergespiegelt werden. Neben dem Finanzinstitut kann es auch eine Bank in einem Park sein. Damit die Bedeutung des Wortes definiert werden kann, muss der Kontext um “Bank” angeschaut werden. In der Attention können die anderen Tokens, welche auch eingebettet wurden, den Vektor für “Bank” beeinflussen. Somit kann innerhalb der Attention das Wort “Bank” beeinflusst werden, damit dies besser eine Parkbank repräsentiert. In diesem Abschnitt werden wir nur die Self-Attention genauer anschauen, die Cross-Attention lassen wir aus.</p>
          <div class="mt-6 bg-gray-100 p-6 rounded-lg">
            <svg viewBox="0 0 800 400" xmlns="http://www.w3.org/2000/svg" class="w-full">
              <defs>
                <marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                  <path d="M 0 0 L 10 5 L 0 10 z" fill="#9ca3af"/>
                </marker>
                <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                  <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
                  <feOffset dx="2" dy="2" result="offsetblur"/>
                  <feMerge>
                    <feMergeNode/>
                    <feMergeNode in="SourceGraphic"/>
                  </feMerge>
                </filter>
              </defs>
              <style>
              .node { stroke-width: 1.5; filter: url(#shadow); }
              .node-text { font-family: &apos;Inter&apos;, sans-serif; font-size: 18px; fill: #1f2937; text-anchor: middle; dominant-baseline: central; }
              .label-text { font-family: &apos;Inter&apos;, sans-serif; font-size: 16px; fill: #6b7280; text-anchor: middle; }
              .context-geld { fill: #fef3c7; stroke: #fde68a; }
              .context-park { fill: #dcfce7; stroke: #bbf7d0; }
              .vektor-bank { fill: #e0e7ff; stroke: #c7d2fe; }
              .result-geld { fill: #fde047; stroke: #facc15; }
              .result-park { fill: #86efac; stroke: #4ade80; }
              .arrow-path { fill: none; stroke: #9ca3af; stroke-width: 2.5; marker-end: url(#arrow); }
              </style>
              <!--Main Title-->
              <text x="400" y="40" class="label-text" font-size="24" font-weight="bold">Kontext-basierte Wortbedeutung</text>
              <!--Bank Vektor (Center)-->
              <g transform="translate(325, 175)">
                <rect width="150" height="50" rx="10" class="node vektor-bank"/>
                <text x="75" y="25" class="node-text">Vektor &quot;Bank&quot;</text>
              </g>
              <!--Geld Kontext (Top Left)-->
              <g transform="translate(50, 80)">
                <rect width="150" height="50" rx="10" class="node context-geld"/>
                <text x="75" y="25" class="node-text">Kontext &quot;Geld&quot;</text>
              </g>
              <!--Park Kontext (Bottom Left)-->
              <g transform="translate(50, 270)">
                <rect width="150" height="50" rx="10" class="node context-park"/>
                <text x="75" y="25" class="node-text">Kontext &quot;Park&quot;</text>
              </g>
              <!--Finanzinstitut Ergebnis (Top Right)-->
              <g transform="translate(600, 80)">
                <rect width="150" height="50" rx="10" class="node result-geld"/>
                <text x="75" y="25" class="node-text">&quot;Finanzinstitut&quot;</text>
              </g>
              <!--Parkbank Ergebnis (Bottom Right)-->
              <g transform="translate(600, 270)">
                <rect width="150" height="50" rx="10" class="node result-park"/>
                <text x="75" y="25" class="node-text">&quot;Parkbank&quot;</text>
              </g>
              <!--Arrows-->
              <path class="arrow-path" d="M 200 105 C 300 105, 270 200, 320 200"/>
              <path class="arrow-path" d="M 475 200 C 525 200, 550 105, 600 105"/>
              <path class="arrow-path" d="M 200 295 C 300 295, 270 200, 320 200"/>
              <path class="arrow-path" d="M 475 200 C 525 200, 550 295, 600 295"/>
              <text x="240" y="205" class="label-text">beeinflusst</text>
            </svg>
          </div>
        </div>

        <div class="border-t pt-8">
          <h2 class="text-2xl font-bold mb-4">Query und Key Vektoren</h2>
          <p>Innerhalb der Attention wird mit jedem Token zwei Matrixmultiplikationen durchgeführt. Beide Matrizen bestehen komplett aus Modelparameter, welche, während dem Lernen der LLM definiert werden. Als Ergebnis der beiden Multiplikationen erhalten wir Query und Key Vektoren, diese befinden sich in einer kleineren Dimension im Vergleich zum ursprünglichen Einbettungsraum.</p>
          <p class="mt-4">Die erste Matrixmultiplikation ergibt einen Query-Vektor, welcher eine Frage an die umliegenden Tokens widerspiegelt. Ein sehr stark vereinfachtes Beispiel ist, dass die Matrik, welche bei der Matrixmultiplikation für den Query-Vektor verwendet wird, bei Nomen den Fragenvektor “Gibt es Adjektive vor mir?” zurückgibt.</p>
          <p class="mt-4">Bei der zweiten Matrixmultiplikation erhalten wir einen Key-Vektor. Der Key-Vektor ist die Antwort zu der Frage des Query-Vektors. Hier würden in unserem Beispiel die Adjektive die Antwort geben “Ich bin ein Adjektiv an der Position X”.</p>
          <div class="mt-6 bg-gray-100 p-6 rounded-lg">
            <svg viewBox="0 0 800 400" xmlns="http://www.w3.org/2000/svg" class="w-full">
              <style>@keyframes query-vec-gen-anim{0%,30%{opacity:0;transform:scale(.5)}40%,to{opacity:1;transform:scale(1)}}@keyframes key-vec-gen-anim{0%,50%{opacity:0;transform:scale(.5)}60%,to{opacity:1;transform:scale(1)}}.flow-text{font-family:monospace;font-size:16px}.matrix{fill:#e0e7ff;stroke:#6366f1;stroke-width:1}.output-vector{fill:#fee2e2;stroke:#ef4444;stroke-width:1}.path-line{stroke:#9ca3af;stroke-width:2;fill:none;marker-end:url(#arrow)}</style>
              <defs>
                <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                  <path d="m0 0 10 5-10 5z" fill="#9ca3af"/>
                </marker>
              </defs>
              <text x="50" y="30" class="flow-text font-semibold">Input Token Vektor</text>
              <text x="300" y="30" class="flow-text font-semibold">Matrizen</text>
              <text x="600" y="30" class="flow-text font-semibold">Output Vektoren</text>
              <rect x="100" y="180" width="100" height="40" rx="5" style="fill:#dbeafe;stroke:#3b82f6;stroke-width:1"/>
              <text x="150" y="205" text-anchor="middle" class="flow-text">Token</text>
              <rect x="280" y="80" width="150" height="60" rx="5" class="matrix"/>
              <text x="355" y="115" text-anchor="middle" class="flow-text">Query Matrix</text>
              <path d="M200 200c30-20 40-90 75-90" class="path-line"/>
              <g style="animation:query-vec-gen-anim 8s infinite">
                <path d="M430 110h150" class="path-line"/>
                <rect x="580" y="90" width="120" height="40" rx="5" class="output-vector"/>
                <text x="640" y="115" text-anchor="middle" class="flow-text">Query (q)</text>
              </g>
              <rect x="280" y="260" width="150" height="60" rx="5" class="matrix"/>
              <text x="355" y="295" text-anchor="middle" class="flow-text">Key Matrix</text>
              <path d="M200 200c30 20 30 90 80 90" class="path-line"/>
              <g style="animation:key-vec-gen-anim 8s infinite">
                <path d="M430 290h150" class="path-line"/>
                <rect x="580" y="270" width="120" height="40" rx="5" class="output-vector"/>
                <text x="640" y="295" text-anchor="middle" class="flow-text">Key (k)</text>
              </g>
            </svg>
          </div>
        </div>

        <div class="border-t pt-8">
          <h2 class="text-2xl font-bold mb-4">Skalarprodukt vom Key und Query Vektor</h2>
          <p>Sobald für jeden Token ein Key und Query-Vektor berechnet wurde, wird das Skalarprodukt von jedem Key-Vektor mit jedem Query-Vektor ausgerechnet. Wenn das Skalarprodukt von einem Query-Vektor und einem Key-Vektor stark positiv ist, bedeutet dies, dass das Token vom Key-Vektor auf das Token vom Query-Vektor Einfluss haben sollte. Bei Skalaren nahe bei Eins oder im Minus beeinflussen die Token sich nicht oder nur sehr schwach gegenseitig. Bei unserem Beispiel würde das Skalarprodukt von einem Adjektiv Key-Vektor und einem Nomen Query-Token ein sehr hohes Skalarprodukt ergeben und somit aufzeigen, dass ein Adjektiv ein Nomen stark beeinflusst.</p>
          <div class="mt-6 bg-gray-100 p-6 rounded-lg overflow-x-auto">
            <p class="text-center font-semibold mb-4">Beispielsatz: "Das braune Brot"</p>
            <div class="flex justify-center">
              <div class="grid grid-cols-4 gap-1 text-sm text-center">
                <div class="p-2 font-bold"></div>
                <div class="p-2 font-bold">Query: "Das"</div>
                <div class="p-2 font-bold">Query: "braune"</div>
                <div class="p-2 font-bold">Query: "Brot"</div>

                <!-- Key: "Das" -->
                <div class="p-2 font-bold self-center">Key: "Das"</div>
                <div class="p-4 bg-blue-200 rounded">3.2</div>
                <div class="p-4 bg-blue-100 rounded">1.5</div>
                <div class="p-4 bg-blue-100 rounded">2.1</div>

                <!-- Key: "braune" -->
                <div class="p-2 font-bold self-center">Key: "braune"</div>
                <div class="p-4 bg-blue-100 rounded">1.1</div>
                <div class="p-4 bg-blue-200 rounded">4.8</div>
                <div class="p-4 bg-red-300 rounded font-bold">15.3</div>

                <!-- Key: "Brot" -->
                <div class="p-2 font-bold self-center">Key: "Brot"</div>
                <div class="p-4 bg-blue-100 rounded">0.5</div>
                <div class="p-4 bg-red-300 rounded font-bold">12.1</div>
                <div class="p-4 bg-blue-200 rounded">5.5</div>
              </div>
            </div>
            <p class="text-center text-sm mt-4 text-gray-600">Die Skalarprodukte zwischen den Schlüssel- und Anfrage-Vektoren. Ein hoher Wert (rot) zwischen dem Schlüssel "braune" und der Anfrage "Brot" signalisiert eine starke Beziehung.</p>
          </div>
        </div>

        <div class="border-t pt-8">
          <h2 class="text-2xl font-bold mb-4">Softmax</h2>
          <p>Sämtliche Skalarprodukte von Key-Vektoren, welche nach einem Query-Vektor in der Reihenfolge sind, werden auf minus Unendlich gesetzt. Dies bewirkt, dass in folgendem Beispielsatz: “Das braune Brot auf dem schwarzen Tisch” das Token für “schwarzen” das Token für “Brot” nicht beeinflusst.</p>
          <p class="mt-4">Anschliessend wir ein Softmax von allen Skalaren von einem Query-Vektor und allen Key-Vektoren genommen. Softmax setzt alle Werte im Minus Bereich auf Null und gewichtet alle positiven Zahle so, dass am Schluss die Summe sämtlicher Zaheln zusammenaddiert Eins ergeben. Das Ergebnis vom Softmax ist eine normalisierte Spalte, in welcher abgelesen werden kann welcher Token welchen Token wie fest beeinflussen muss.</p>
          <div class="mt-6 bg-gray-100 p-6 rounded-lg overflow-x-auto">
            <p class="text-center font-semibold mb-4">Attention-Gewichte nach Softmax</p>
            <div class="flex justify-center">
              <div class="grid grid-cols-4 gap-1 text-sm text-center">
                <div class="p-2 font-bold"></div>
                <div class="p-2 font-bold">Query: "Das"</div>
                <div class="p-2 font-bold">Query: "braune"</div>
                <div class="p-2 font-bold">Query: "Brot"</div>

                <!-- Key: "Das" -->
                <div class="p-2 font-bold self-center">Key: "Das"</div>
                <div class="p-4 bg-green-500 rounded font-bold">1.00</div>
                <div class="p-4 bg-green-300 rounded">0.21</div>
                <div class="p-4 bg-green-200 rounded">0.06</div>

                <!-- Key: "braune" -->
                <div class="p-2 font-bold self-center">Key: "braune"</div>
                <div class="p-4 bg-gray-400 rounded text-white">-inf --> 0.00</div>
                <div class="p-4 bg-green-400 rounded">0.79</div>
                <div class="p-4 bg-green-500 rounded font-bold">0.85</div>

                <!-- Key: "Brot" -->
                <div class="p-2 font-bold self-center">Key: "Brot"</div>
                <div class="p-4 bg-gray-400 rounded text-white">-inf --> 0.00</div>
                <div class="p-4 bg-gray-400 rounded text-white">-inf --> 0.00</div>
                <div class="p-4 bg-green-200 rounded">0.09</div>
              </div>
            </div>
            <p class="text-center text-sm mt-4 text-gray-600">Nach Softmax werden die Werte zu Wahrscheinlichkeiten normalisiert. Werte, die in der Zukunft liegen, werden maskiert (-inf). Man sieht, dass die Anfrage "braune" zu 85% vom Schlüssel "Brot" beeinflusst wird.</p>
          </div>
        </div>

        <div class="border-t pt-8">
          <h2 class="text-2xl font-bold mb-4">Beeinflussung</h2>
          <p>Nun wissen wir, zum Beispiel, dass “braun” die Einbettung für “Brot” beeinflussen muss. Für die eigentlich Beeinflussung muss nun die Einbettung vom "Brot” Token angepasst werden. Hier wird eine weitere Matrixmultiplikation gerechnet. Auch bei dieser besteht die Matrik aus Modelparameter, die wiederum, während dem Lernen gesetzt werden. Die Einbettung von jedem Token wird mit der Matrik multipliziert, draus erhält man einen weiteren Vektor, der aufzeigt, was bei einem anderen Token addiert werden muss, um diesen zu beeinflussen. Diesen Vektor nennen wir von nun an “Value-Vektor”. Bei unserem Beispiel würde die Multiplikation, der Matrik, mit dem Vektor für “braun” ein Value-Vektor ergeben, welcher zu “Brot” addiert werden kann. Das Ergebnis daraus wäre “Brot” mit dem Kontext “braun”.</p>
          <p class="mt-4">Da wir mehrere Tokens haben, welche unterschiedlich stark einen Token beeinflussen, müssen sämtliche Value-Vektoren mit dem Softmax Ergebnis des gleichen Key-Token multipliziert werden. Anschliessend werden alle Ergebnisse für ein Query-Token zusammenaddiert, um einen Vektor zu erhalten, welcher die unterschiedlichen Beeinflussungen beinhaltet. In unserem Beispiel könnte also mit einem Vektor zum Token “Brot” “braun, hell, frisch” als Kontext dazu addiert werden, wobei die einzelnen Kontextwörter unterschiedlich gewichtet wurden.</p>
          <p class="mt-4">Nun konnten wir erfolgreich Kontext, aufgrund anderen Tokens, zu einem zuvor Kontextlosen Token hinzufügen.</p>
          <div class="mt-6 bg-gray-100 p-6 rounded-lg">
            <svg viewBox="0 0 850 400" xmlns="http://www.w3.org/2000/svg" class="w-full">
              <style>
              .label{font-family:sans-serif;font-size:16px;text-anchor:middle}.op-label,.token-label{font-family:monospace;text-anchor:middle}.token-label{font-size:14px}.op-label{font-size:24px}.value-vec{fill:#dcfce7;stroke:#22c55e;stroke-width:1}.attn-score,.weighted-vec{fill:#fef9c3;stroke:#f59e0b;stroke-width:1}.weighted-vec{fill:#fee2e2;stroke:#ef4444}.path-line{stroke:#9ca3af;stroke-width:2;fill:none;marker-end:url(#arrow)}
              </style>
              <defs>
                <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="5" markerHeight="6" orient="auto-start-reverse">
                  <path d="m0 0 10 5-10 5z" fill="#9ca3af"/>
                </marker>
              </defs>
              <text x="425" y="30" class="label font-bold">Berechnung des neuen Token-Vektors</text>
              <text x="100" y="80" class="label">Value Vektoren (v)</text>
              <text x="250" y="80" class="label">Attn Scores (a)</text>
              <text x="450" y="80" class="label">Gewichtete Vektoren</text>
              <text x="590" y="150" class="label">Einbettungs Vektor (e)</text>
              <rect x="50" y="100" width="100" height="40" rx="5" class="value-vec"/>
              <text x="100" y="125" class="token-label">v(&quot;Das&quot;)</text>
              <text x="175" y="125" class="op-label">x</text>
              <rect x="200" y="100" width="100" height="40" rx="5" class="attn-score"/>
              <text x="250" y="125" class="token-label">a = 0.05</text>
              <path d="M300 120h95" class="path-line"/>
              <rect x="400" y="100" width="100" height="40" rx="5" class="weighted-vec"/>
              <text x="450" y="125" class="token-label">vg(&quot;Das&quot;)</text>
              <rect x="50" y="180" width="100" height="40" rx="5" class="value-vec"/>
              <text x="100" y="205" class="token-label">v(&quot;braune&quot;)</text>
              <text x="175" y="205" class="op-label">x</text>
              <rect x="200" y="180" width="100" height="40" rx="5" class="attn-score"/>
              <text x="250" y="205" class="token-label">a = 0.85</text>
              <path d="M300 200h95" class="path-line"/>
              <rect x="400" y="180" width="100" height="40" rx="5" class="weighted-vec"/>
              <text x="450" y="205" class="token-label">vg(&quot;braune&quot;)</text>
              <rect x="50" y="260" width="100" height="40" rx="5" class="value-vec"/>
              <text x="100" y="285" class="token-label">v(&quot;Brot&quot;)</text>
              <text x="175" y="285" class="op-label">x</text>
              <rect x="200" y="260" width="100" height="40" rx="5" class="attn-score"/>
              <text x="250" y="285" class="token-label">a = 0.10</text>
              <path d="M300 280h95" class="path-line"/>
              <rect x="400" y="260" width="100" height="40" rx="5" class="weighted-vec"/>
              <text x="450" y="285" class="token-label">vg(&quot;Brot&quot;)</text>
              <text x="450" y="246" class="op-label" fill="#6b7280">+</text>
              <text x="450" y="166" class="op-label" fill="#6b7280">+</text>
              <text x="525" y="210" class="op-label" fill="#6b7280">+</text>
              <rect x="550" y="180" width="80" height="40" rx="5" style="fill:#e9d5ff;stroke:#a855f7;stroke-width:2"/>
              <text x="590" y="205" class="token-label">e(Brot)</text>
              <path d="M630 200h65" class="path-line"/>
              <rect x="700" y="180" width="110" height="40" rx="5" style="fill:#e9d5ff;stroke:#a855f7;stroke-width:2"/>
              <text x="755" y="195" class="token-label">Neuer Vektor</text>
              <text x="755" y="215" class="token-label">mit Kontext</text>
            </svg>
          </div>
        </div>

        <div class="border-t pt-8">
          <h2 class="text-2xl font-bold mb-4">Multi-Headed Attention</h2>
          <p>Sämtliche Schritte, welche nun erklärt wurden, werden in der Fachsprache einen “Head” genannt. In fast allen LLM’s gibt es nicht nur einen “Head” in der Attention, sondern viele aneinander gereihte “Head”. Dies wird dann Multi-Headed Attention genannt. Der Hauptgrund, wieso eine Multi-Headed Attention durchgeführt wird, ist, dass bei jedem einzelnen “Head” neue Matriken verwendet werden, welche aus unterschiedlichen Modellparamter bestehen. Somit kann Kontext noch schneller und genauer bei Tokens hinzugefügt werden.</p>
          <div class="mt-6 bg-gray-100 p-6 rounded-lg">
            <svg viewBox="0 0 900 250" xmlns="http://www.w3.org/2000/svg" class="w-full">
              <defs>
                <marker id="arrow-h" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                  <path d="M 0 0 L 10 5 L 0 10 z" fill="rgb(156, 163, 175)"></path>
                </marker>
              </defs>
              <style>
              .label { font-family: sans-serif; font-size: 16px; text-anchor: middle; }
              .head-label { font-family: monospace; font-size: 14px; text-anchor: middle; }
              .head-box { fill: rgb(220, 252, 231); stroke: rgb(34, 197, 94); }
              .path-line-h { stroke: rgb(156, 163, 175); stroke-width: 2; fill: none; marker-end: url(#arrow-h); }
              </style>

              <text x="450" y="30" class="label font-bold">Multi-Headed Attention</text>

              <!-- Input -->
              <text x="100" y="125" class="label">Input</text>
              <path d="M 125 120 H 240" class="path-line-h" />

              <!-- Heads -->
              <g>
                <rect x="240" y="90" width="100" height="60" rx="5" class="head-box" />
                <text x="290" y="125" class="head-label">Head 1</text>
              </g>
              <path d="M 340 120 H 400" class="path-line-h" />

              <g>
                <rect x="400" y="90" width="100" height="60" rx="5" class="head-box" />
                <text x="450" y="125" class="head-label">Head 2</text>
              </g>
              <path d="M 500 120 H 560" class="path-line-h" />

              <g>
                <rect x="560" y="90" width="100" height="60" rx="5" class="head-box" />
                <text x="610" y="125" class="head-label">Head n</text>
              </g>

              <!-- Concatenate & Final Output -->
              <path d="M 660 120 H 730" class="path-line-h" />
              <text x="760" y="125" class="label">Output</text>

            </svg>
          </div>
        </div>
      </div>
    </main>
  </body>
</html>
